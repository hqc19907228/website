---
title: '分布式流程的重构与整体设计'
tag: '分布式系统, 后端, 低代码, go 语音, 工作流'
keywords: '分布式系统, 后端, 低代码, go 语音, 工作流, 低代码, low-code'
description: '如何更好的支持自由流的控制，对流程实现中存在，单人办理、多人顺序、多人并行、抢占办理、内部循环、人工合并等场景的支持？'
createTime: '2021-11-19'
author: '谢溢文'
snapshot: 'https://raw.githubusercontent.com/quanxiang-cloud/website/main/static/images/blogs/Distributed%20process%20refactoring%20and%20overall%20design/cover.png'
---

## 什么是工作流

让我们从火车运输的例子说起吧。火车将一批货物从一点运送到另外一点的过程中，需要进行大量的设计考量。轨道是火车的运送路径，不同的轨道可能会通往不同的目的地，相同的目的地也可以有不同的路径。即此过程会有很多的灵活性，也可以在必要的时候选择路径。

在业务流程的世界中，“轨道”即工作流。工作流可以很长，可以包含多个停止节点；不一定是直线，可以通过不同的预定路径，到达不同的站点。

简言之，为业务流程创建工作流的时候，其实是在铺设轨道，告诉火车通往何处。设计过程包含了很多因素：



### 1、“火车车厢”是表单，“装载的货物”即数据

火车车厢为了装载货物，会根据货物类型（如：煤炭、海鲜、活禽）不同，进行不同的设计。同理，表单也会根据不同行业的数据特点，设定不同的表现形式及权限。

 

### 2、“站点”即任务流程节点

最基本的有起点站（开始节点）、终点站（结束节点）。一个站点可以是一个大型省会城市，比如：武汉拥有武汉站、武昌站、汉口站。如果每个火车站都需要停靠，即对应到**会签节点**；如果只需任一停靠，即是**或签节点**。站内的工作人员，参与完成各项工作，可能是一个角色，也可能是一个部门、一种角色，对应**流程处理人**。

站点也可以是一个具有射频识别(RFID)采集能力的 ETC 门架，自动完成一些工作的**自动节点**。或是一个道岔，可以完成火车切换线路的**网关节点**。甚至可能是在特定地点完成煤炭运输中限制粉尘的自动喷雾装置、活禽运输中的加氧装置…对应**零时插入节点**。

可以看出，站点会根据货物的特点而有不同的功能需求，一个流程中由多个不同功能的节点组合完成一个任务。对于低代码平台而言，需要在面对各种行业的不同特点时，提供灵活的解决方式，这与火车运输类似。

那么工作流中各种自由流的需求场景，是如何实现的呢? 



## 低代码平台流程设计

目前开源主流的流程框架有：activities[1]、flowable[2]、camunda[3] 等，在设计上更多的是偏向对 bpmn 等标准协议的支持，对自由流的支持并不理想。技术实现一般有如下几种方式：

1. 在 runtime 阶段动态修改流程线的指向，节点结束后需再次修改；
2. 修改源码重新编译，或是查阅源码直接操作数据库对应的表。

这对于技术人员来说，可能需要付出巨大的时间成本、学习成本实现一个很小的功能，并且容易在细节上出错。



低代码平台的工作流设计，着重考虑在多业务场景下，对自由节点流转进行简单可控的支持。在架构上具有分布式部署的能力，同时要具备弹性的、开放的能力满足平台化的需求。另外将业务逻辑需求与流程的流转控制进行拆分，提供通用的节点。至于运输中是为煤炭喷雾加水还是为活禽加氧这样的业务需求，将交由业务逻辑处理。

<div align=center>
<img src="https://raw.githubusercontent.com/quanxiang-cloud/website/main/static/images/blogs/Distributed%20process%20refactoring%20and%20overall%20design/workflow1.png" width = 40%/>
</div>

在系统设计上，主要由如上图组成。`flow` 专注业务逻辑实现；`process` 进行流程流转控制与解析；`event center` 是消息事件中心，流程流转过程中，向外推送各种边界事件，业务方监听相应的事件完成业务实现。同时由于拆分，带来的数据一致性方面的问题，需要由 `TC` 来协调实现分布式事务，保证流程数据的最终一致。基于 Golang 开发，各服务都分布式独立部署。

通过火车运输的例子，我们知道工作流就是在站点之间铺设铁轨，然后通过各种要素的组合实现业务流程。在软件世界中，我们连接两个节点，不需要真的铺设一段铁轨，只需要在节点中存放一个指针，指向节点的地址。

### 节点（Node）


<div align=center>
<img src="https://raw.githubusercontent.com/quanxiang-cloud/website/main/static/images/blogs/Distributed%20process%20refactoring%20and%20overall%20design/workflow2.png" width = 40%/>
</div>

节点是流程的基础，节点本身是无状态的、资源化的，当按照一定的规则，将不同类型的节点组合起来，便是一种特定的业务流程。

 

因此在节点的设计上，我们遵循以上原则并参照数据结构中链表的实现，将节点进行抽象，简化了 bpmn 协议中线的概念。每种节点都有基本的属性，表示节点的 id、类型、名字、下个节点的 id、处理人等。同时需要实现节点接口：处理节点进入时、离开时和其他需要处理的基本逻辑。

 

不同类型的节点，完成不同的工作。同时抽象出节点工厂 nodeFactory 来管理各种节点，在进行节点解析时，由节点工厂来完成各种节点的调度。当有新的业务需求时，只需构造一种新的节点类型完成特定的需求，并将其加入到工厂中，便可以作为资源提供服务。通过这种组合方式实现需求与 Golang 提倡组合的思想是一致的。



### 模型（Model）

<div align=center>
<img src="https://raw.githubusercontent.com/quanxiang-cloud/website/main/static/images/blogs/Distributed%20process%20refactoring%20and%20overall%20design/workflow3.png" width = 50%/>
</div>

模型就是流程图的元信息，是用户通过可视化页面，对各种类型的节点的组合的图像化展示数据的抽象。相较于其他的开源实现方式，这里的线仅是一种逻辑关系展示，不具备任何流程相关的属性及作用。可以说和链表数据结构中的线是一样的，只是虚拟的存在。



### 实例（Instance）

<div align=center>
<img src="https://raw.githubusercontent.com/quanxiang-cloud/website/main/static/images/blogs/Distributed%20process%20refactoring%20and%20overall%20design/workflow4.png" width = 50%/>
</div>

实例是模型的具象，他们的关系就像月饼模具与月饼。实例如已经发车的火车，是业务逻辑执行的核心，同样是流程流转的核心。

task 是实例中等待处理的任务，包含：人工处理的任务（assignee）和自动处理的任务（service）。

- assignee 需要由 model 中配置的相应人处理。当这个人开始处理这个任务时，他此时便如同火车的司机，可以在处理时发送相应的指令，如：
  - 让流程跳过某些节点（改变节点的 nextNode）；
  - 插入临时节点（改变本节点和插入节点的 nextNode）；
  - 回退、回到起点（删掉已有任务，并初始化一个起点任务）；
  - 转让任务（将自己的任务抄送给指定人，删掉自己的任务）等等操作。
- service 通过 event center 发送事件通知，由业务根据具体的业务类型完成相关的工作（站内信、邮件等）。



### 节点实例（NodeInstance）

画模型阶段选择的节点属于模型节点；在实例执行阶段，临时加的节点，属于实例节点。实例节点只属于对应的实例，不会改变模型的结构。那么在流程执行完成后，如何获知流程执行的完整画像？

答案是节点实例。节点实例是实例执行过程中，按节点维度记录，最终形成实例执行过程中的一条完整的节点链记录。

当一个流程执行完成后，由于加签等临时节点的加入，流程的实际流转与 model 不一致。当需要了解最终流程流转后的整个过程，只需通过流程实例 id 查询，按 nodeInstance 维度还原整个流转过程，即可得到最终的流程流转情况。

### 执行（Execution）

<div align=center>
<img src="https://raw.githubusercontent.com/quanxiang-cloud/website/main/static/images/blogs/Distributed%20process%20refactoring%20and%20overall%20design/workflow5.png" width = 30%/>
</div>

执行是为了处理分支而设计的，虽然在我们的设计里，线已经变成了一个虚拟的存在。但当有分支存在时，我们需要记录分支之间的隶属关系。



当流程实例启动时，自动生成一个主的 executionId。每当一个分支出现时，便会新建一个分支 execution，它的父 execution 是主 execution。这样便形成了一个树状的 execution 关系结构。

​	

分支的合流条件可以是任一拒绝，或全部拒绝。任一拒绝表示，当准备合流的几个分支中，有任意一个分支拒绝了，则整个这条分支所在的分支将拒绝。这意味着，与该分支平行的所有分支的节点的任务，已经无需继续执行，需要被清理。此时，通过递归的遍历该分支的所有平行分支及他们的子分支，即可完成所有 task的清理，达到业务上的需求。

通过 execution 的树，可以实现分支多级嵌套的复杂流程，在拒绝逻辑下的任务清理及解析。

### 事件（Event）

事件消息是沟通流程交互中的重要实现，设计实现上使用 RPC 通信方式，有同步事件与异步事件。

- 同步事件：用于处理流程实例执行过程中，动态变量的值传递。包括：任务处理人、分支条件值、流程变量等，在画流程图阶段无法具体指定，必须在实例执行过程中动态查询获取的情况。

- 异步事件：主要是消息通知类，比如开启流程实例、节点开始、节点完成等对流程的流转没有实质影响的事件。



## 总结

低代码的流程设计，是基于以上这些基本的流程要素的组合，来达到对流程流转的解析、控制。如何更好的支持自由流的控制，对流程实现中存在，单人办理、多人顺序、多人并行、抢占办理、内部循环、人工合并等场景，主办加签、会办加签、协办、回退、回撤、子流程、节点跳转等多种中国式流程操作动作的需求。如何优雅的、灵活的实现，我们也在探索与实践，期待更多的参与和建议。